<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Christmas Tree with Hand Gestures</title>
    
    <!-- å¼•å…¥ MediaPipe åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050505;
            background: radial-gradient(circle at center, #1a1a1a 0%, #000000 100%);
            font-family: 'Helvetica Neue', Arial, sans-serif;
            color: white;
            touch-action: none;
            cursor: none;
        }
        
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            pointer-events: none;
            mix-blend-mode: difference;
        }

        h1 {
            font-size: 1.1rem;
            font-weight: 300;
            margin: 0;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.9);
        }

        p {
            font-size: 0.75rem;
            margin-top: 8px;
            color: rgba(255, 255, 255, 0.6);
            letter-spacing: 0.05em;
        }

        .instruction {
            display: block;
            margin-top: 5px;
        }

        #btn-camera {
            pointer-events: auto;
            margin-top: 15px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s;
            border-radius: 20px;
            position: relative;
            z-index: 101;
        }

        #btn-camera:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* æ‘„åƒå¤´é¢„è§ˆçª—å£ */
        .camera-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            z-index: 20;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            overflow: hidden;
            background: #000;
            display: none; /* é»˜è®¤éšè—ï¼Œç‚¹å‡»æŒ‰é’®åæ˜¾ç¤º */
            transform: scaleX(-1); /* é•œåƒç¿»è½¬é¢„è§ˆ */
        }

        .input_video {
            display: none; /* éšè—åŸå§‹ video æ ‡ç­¾ */
        }
        
        #output_canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #loading-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.7rem;
            color: #aaa;
            display: none;
        }

        #glow-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 600px;
            height: 600px;
            transform: translate(-50%, -50%);
            background: radial-gradient(circle, rgba(40, 80, 40, 0.1) 0%, rgba(0,0,0,0) 70%);
            pointer-events: none;
            z-index: 0;
        }
    </style>
</head>
<body>

    <div id="glow-overlay"></div>

    <div id="ui-layer">
        <h1>Organic Geometry Tree</h1>
        <p>
            <span class="instruction">ğŸ–±ï¸ é¼ æ ‡äº¤äº’ï¼šå·¦å³ç§»åŠ¨æ—‹è½¬ Â· ç‚¹å‡»çˆ†å‘</span>
            <span class="instruction">ğŸ“· æ‘„åƒå¤´äº¤äº’ï¼šæ‰‹æŒå·¦å³ç§»åŠ¨ Â· æåˆæ‰‹æŒ‡çˆ†å‘</span>
        </p>
        <button id="btn-camera">å¼€å¯æ‘„åƒå¤´æ§åˆ¶</button>
    </div>

    <!-- æ‘„åƒå¤´é¢„è§ˆåŒºåŸŸ -->
    <div class="camera-container" id="camera-preview">
        <video class="input_video"></video>
        <canvas id="output_canvas" width="160" height="120"></canvas>
        <div id="loading-text">Loading AI...</div>
    </div>

    <canvas id="treeCanvas"></canvas>

<script>
    /**
     * PART 1: 3D Christmas Tree Core Logic
     */
    const canvas = document.getElementById('treeCanvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    let particles = [];
    
    // äº¤äº’çŠ¶æ€å˜é‡
    let targetRotationSpeed = 0.003;
    let currentRotationSpeed = 0.003;
    let autoRotate = true;
    let explodeForce = 0;
    
    // åŒºåˆ†é¼ æ ‡æ§åˆ¶å’Œæ‘„åƒå¤´æ§åˆ¶
    let isHandControlling = false;
    let cameraInstance = null;
    let handsInstance = null;
    let isCameraRunning = false;

    const PARTICLE_COUNT = 8000; // ä¼˜åŒ–ï¼šå‡å°‘ç²’å­æ•°é‡
    const TREE_HEIGHT = 500;     
    const BASE_RADIUS = 200;     
    const FOCAL_LENGTH = 800;    
    const SPIN_LAYER_DENSITY = 1.5; 
    const CONFETTI_COUNT = 250; // ä¼˜åŒ–ï¼šå‡å°‘å½©å¸¦æ•°é‡
    const GIFT_COUNT = 10; // ä¼˜åŒ–ï¼šå‡å°‘ç¤¼ç‰©æ•°é‡
    const LEAF_COUNT = 1200; // ä¼˜åŒ–ï¼šå‡å°‘æ ‘å¶æ•°é‡
    const ORNAMENT_COUNT = 120; // ä¼˜åŒ–ï¼šå‡å°‘é“ƒé“›æ˜Ÿæ˜Ÿæ•°é‡
    
    // æ˜Ÿæ˜Ÿè·³åŠ¨æ§åˆ¶
    let hasExplodedOnce = false; // æ˜¯å¦å·²ç»çˆ†å¼€è¿‡ä¸€æ¬¡
    let starJumpOffset = 0; // æ˜Ÿæ˜Ÿè·³åŠ¨åç§»

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // å½©å¸¦ç¢ç‰‡ç±»
    class Confetti {
        constructor() {
            this.init();
        }
        
        init() {
            // éšæœºåˆ†å¸ƒåœ¨æ ‘çš„èŒƒå›´å†…ï¼Œåº•éƒ¨æ›´å¯†é›†
            let t = Math.pow(Math.random(), 0.4); // æ›´å°çš„æŒ‡æ•°è®©åº•éƒ¨æ›´å¯†é›†
            this.y = -TREE_HEIGHT / 2 + t * TREE_HEIGHT;
            let yPercent = (this.y + TREE_HEIGHT / 2) / TREE_HEIGHT;
            this.baseRadius = yPercent * BASE_RADIUS * (0.7 + Math.random() * 0.5);
            this.angle = Math.random() * Math.PI * 2;
            
            // ç¢ç‰‡å¤§å°å’Œå½¢çŠ¶
            this.width = 3 + Math.random() * 5;
            this.height = 2 + Math.random() * 3;
            this.rotation = Math.random() * Math.PI * 2;
            this.rotationSpeed = (Math.random() - 0.5) * 0.2;
            
            // é¢œè‰²
            const colors = [
                '#FFD700', '#FF4444', '#C0C0C0', '#FF6B6B', 
                '#4169E1', '#FFB6C1', '#00CED1', '#FF8C00',
                '#9370DB', '#32CD32', '#FF69B4', '#FAFAD2'
            ];
            this.color = colors[Math.floor(Math.random() * colors.length)];
            
            // çˆ†ç‚¸é€Ÿåº¦
            this.vx = (Math.random() - 0.5) * 30;
            this.vy = (Math.random() - 0.5) * 30;
            this.vz = (Math.random() - 0.5) * 30;
            this.dx = 0;
            this.dy = 0;
            this.dz = 0;
        }
        
        update() {
            this.rotation += this.rotationSpeed;
            if (explodeForce > 0.01) {
                this.dx += this.vx * explodeForce * 0.6;
                this.dy += this.vy * explodeForce * 0.6;
                this.dz += this.vz * explodeForce * 0.6;
            } else {
                this.dx *= 0.92;
                this.dy *= 0.92;
                this.dz *= 0.92;
            }
        }
        
        render(rotationOffset, ctx) {
            let effectiveAngle = this.angle + rotationOffset;
            let xPos = Math.cos(effectiveAngle) * this.baseRadius + this.dx;
            let zPos = Math.sin(effectiveAngle) * this.baseRadius + this.dz;
            let yPos = this.y + this.dy;
            
            let zDepth = FOCAL_LENGTH + zPos;
            if (zDepth < 10) zDepth = 10;
            let scale = FOCAL_LENGTH / zDepth;
            
            let screenX = width / 2 + xPos * scale;
            let screenY = height / 2 + yPos * scale + 50;
            
            ctx.save();
            ctx.translate(screenX, screenY);
            ctx.rotate(this.rotation);
            ctx.globalAlpha = Math.min(1, scale * 0.9);
            ctx.fillStyle = this.color;
            ctx.fillRect(-this.width * scale / 2, -this.height * scale / 2, 
                        this.width * scale, this.height * scale);
            ctx.restore();
        }
    }
    
    // æ ‘å¶ç±» - è´´ç€åœ£è¯æ ‘è¾¹ç¼˜
    class Leaf {
        constructor() {
            this.init();
        }
        
        init() {
            // æ ‘å¶åˆ†å¸ƒåœ¨æ ‘çš„è¾¹ç¼˜ï¼Œåº•éƒ¨æ›´å¯†é›†
            let t = Math.pow(Math.random(), 0.35); // æ›´å°çš„æŒ‡æ•°è®©åº•éƒ¨æ›´å¯†é›†
            this.y = -TREE_HEIGHT / 2 + t * TREE_HEIGHT;
            let yPercent = (this.y + TREE_HEIGHT / 2) / TREE_HEIGHT;
            // æ ‘å¶è´´ç€è¾¹ç¼˜ï¼Œåªåœ¨80%-110%çš„åŠå¾„èŒƒå›´
            this.baseRadius = yPercent * BASE_RADIUS * (0.8 + Math.random() * 0.3);
            this.angle = Math.random() * Math.PI * 2;
            
            // æ ‘å¶å¤§å°
            this.size = 6 + Math.random() * 10;
            this.rotation = Math.random() * Math.PI * 2;
            this.rotationSpeed = (Math.random() - 0.5) * 0.08;
            
            // ç»¿è‰²å˜åŒ–
            this.hue = 100 + Math.random() * 60;
            this.lightness = 18 + Math.random() * 28;
            
            // çˆ†ç‚¸é€Ÿåº¦
            this.vx = (Math.random() - 0.5) * 25;
            this.vy = (Math.random() - 0.5) * 25;
            this.vz = (Math.random() - 0.5) * 25;
            this.dx = 0;
            this.dy = 0;
            this.dz = 0;
        }
        
        update() {
            this.rotation += this.rotationSpeed;
            if (explodeForce > 0.01) {
                this.dx += this.vx * explodeForce * 0.5;
                this.dy += this.vy * explodeForce * 0.5;
                this.dz += this.vz * explodeForce * 0.5;
            } else {
                this.dx *= 0.92;
                this.dy *= 0.92;
                this.dz *= 0.92;
            }
        }
        
        render(rotationOffset, ctx) {
            let effectiveAngle = this.angle + rotationOffset;
            let xPos = Math.cos(effectiveAngle) * this.baseRadius + this.dx;
            let zPos = Math.sin(effectiveAngle) * this.baseRadius + this.dz;
            let yPos = this.y + this.dy;
            
            let zDepth = FOCAL_LENGTH + zPos;
            if (zDepth < 10) zDepth = 10;
            let scale = FOCAL_LENGTH / zDepth;
            
            let screenX = width / 2 + xPos * scale;
            let screenY = height / 2 + yPos * scale + 50;
            let leafSize = this.size * scale;
            
            ctx.save();
            ctx.translate(screenX, screenY);
            ctx.rotate(this.rotation);
            ctx.globalAlpha = Math.min(0.95, scale * 0.85);
            
            // ç»˜åˆ¶æ ‘å¶å½¢çŠ¶
            ctx.fillStyle = `hsl(${this.hue}, 75%, ${this.lightness}%)`;
            ctx.beginPath();
            ctx.ellipse(0, 0, leafSize / 2, leafSize / 3.5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å¶è„‰
            ctx.strokeStyle = `hsl(${this.hue}, 60%, ${this.lightness - 8}%)`;
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(-leafSize / 2, 0);
            ctx.lineTo(leafSize / 2, 0);
            ctx.stroke();
            
            ctx.restore();
        }
    }
    
    // é“ƒé“›å’Œæ˜Ÿæ˜Ÿè£…é¥°ç±»
    class Ornament {
        constructor() {
            this.init();
        }
        
        init() {
            // åˆ†å¸ƒåœ¨æ ‘çš„è¾¹ç¼˜ï¼Œåº•éƒ¨æ›´å¯†é›†
            let t = Math.pow(Math.random(), 0.4); // æ›´å°çš„æŒ‡æ•°è®©åº•éƒ¨æ›´å¯†é›†
            this.y = -TREE_HEIGHT / 2 + t * TREE_HEIGHT;
            let yPercent = (this.y + TREE_HEIGHT / 2) / TREE_HEIGHT;
            this.baseRadius = yPercent * BASE_RADIUS * (0.95 + Math.random() * 0.15);
            this.angle = Math.random() * Math.PI * 2;
            
            // ç±»å‹ï¼šé“ƒé“›æˆ–æ˜Ÿæ˜Ÿ
            this.type = Math.random() > 0.5 ? 'bell' : 'star';
            this.size = 8 + Math.random() * 8;
            this.rotation = Math.random() * Math.PI * 2;
            this.rotationSpeed = (Math.random() - 0.5) * 0.1;
            this.swingPhase = Math.random() * Math.PI * 2;
            this.swingSpeed = 0.02 + Math.random() * 0.03;
            
            // é¢œè‰²
            const bellColors = ['#FFD700', '#C0C0C0', '#CD7F32', '#FFB6C1', '#87CEEB'];
            const starColors = ['#FFD700', '#FFFF00', '#FFA500', '#FF69B4', '#00FFFF', '#FFFFFF'];
            
            if (this.type === 'bell') {
                this.color = bellColors[Math.floor(Math.random() * bellColors.length)];
            } else {
                this.color = starColors[Math.floor(Math.random() * starColors.length)];
            }
            
            // çˆ†ç‚¸é€Ÿåº¦
            this.vx = (Math.random() - 0.5) * 28;
            this.vy = (Math.random() - 0.5) * 28;
            this.vz = (Math.random() - 0.5) * 28;
            this.dx = 0;
            this.dy = 0;
            this.dz = 0;
        }
        
        update() {
            this.rotation += this.rotationSpeed;
            this.swingPhase += this.swingSpeed;
            if (explodeForce > 0.01) {
                this.dx += this.vx * explodeForce * 0.6;
                this.dy += this.vy * explodeForce * 0.6;
                this.dz += this.vz * explodeForce * 0.6;
            } else {
                this.dx *= 0.92;
                this.dy *= 0.92;
                this.dz *= 0.92;
            }
        }
        
        render(rotationOffset, ctx) {
            let effectiveAngle = this.angle + rotationOffset;
            let swing = Math.sin(this.swingPhase) * 3;
            let xPos = Math.cos(effectiveAngle) * this.baseRadius + this.dx;
            let zPos = Math.sin(effectiveAngle) * this.baseRadius + this.dz;
            let yPos = this.y + this.dy + swing;
            
            let zDepth = FOCAL_LENGTH + zPos;
            if (zDepth < 10) zDepth = 10;
            let scale = FOCAL_LENGTH / zDepth;
            
            let screenX = width / 2 + xPos * scale;
            let screenY = height / 2 + yPos * scale + 50;
            let ornamentSize = this.size * scale;
            
            ctx.save();
            ctx.translate(screenX, screenY);
            ctx.rotate(this.rotation);
            ctx.globalAlpha = Math.min(1, scale * 0.9);
            
            if (this.type === 'bell') {
                // ç»˜åˆ¶åœ†å½¢é“ƒé“›
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 8;
                ctx.shadowColor = this.color;
                
                // åœ†å½¢é“ƒé“›ä¸»ä½“
                ctx.beginPath();
                ctx.arc(0, 0, ornamentSize / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // é“ƒé“›é¡¶éƒ¨æŒ‚é’©
                ctx.strokeStyle = this.color;
                ctx.lineWidth = ornamentSize / 8;
                ctx.beginPath();
                ctx.arc(0, -ornamentSize / 2 - ornamentSize / 6, ornamentSize / 6, 0, Math.PI, true);
                ctx.stroke();
                
                // ä¸­é—´æ¨ªçº¿
                ctx.strokeStyle = this.darkenColor ? this.darkenColor(this.color, 60) : 'rgba(0,0,0,0.4)';
                ctx.lineWidth = ornamentSize / 10;
                ctx.beginPath();
                ctx.moveTo(-ornamentSize / 2.5, 0);
                ctx.lineTo(ornamentSize / 2.5, 0);
                ctx.stroke();
                
                // åªåœ¨ä¸€ç«¯æœ‰é»‘è‰²å°åœ†å½¢ï¼ˆé“ƒèˆŒæ•ˆæœï¼‰
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.arc(0, ornamentSize / 2.5, ornamentSize / 7, 0, Math.PI * 2);
                ctx.fill();
                
                // é«˜å…‰
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.beginPath();
                ctx.arc(-ornamentSize / 5, -ornamentSize / 5, ornamentSize / 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
            } else {
                // ç»˜åˆ¶æ˜Ÿæ˜Ÿ
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    let outerAngle = (i * 72 - 90) * Math.PI / 180;
                    let innerAngle = ((i * 72) + 36 - 90) * Math.PI / 180;
                    ctx.lineTo(Math.cos(outerAngle) * ornamentSize / 2, Math.sin(outerAngle) * ornamentSize / 2);
                    ctx.lineTo(Math.cos(innerAngle) * ornamentSize / 4, Math.sin(innerAngle) * ornamentSize / 4);
                }
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            
            ctx.restore();
        }
        
        darkenColor(color, amount) {
            if (color.startsWith('#')) {
                const hex = color.replace('#', '');
                const r = Math.max(0, parseInt(hex.substr(0, 2), 16) - amount);
                const g = Math.max(0, parseInt(hex.substr(2, 2), 16) - amount);
                const b = Math.max(0, parseInt(hex.substr(4, 2), 16) - amount);
                return `rgb(${r},${g},${b})`;
            }
            return 'rgba(0,0,0,0.4)';
        }
    }
    
    // ç¤¼ç‰©ç›’ç±» - å¤æ‚æ—‹è½¬è·¯å¾„
    class GiftBox {
        constructor(index) {
            this.init(index);
        }
        
        init(index) {
            // å›´ç»•æ ‘åº•éƒ¨åˆ†å¸ƒï¼Œä½¿ç”¨ä¸åŒçš„è½¨é“
            this.baseAngle = (index / GIFT_COUNT) * Math.PI * 2;
            this.orbitRadius = 100 + Math.random() * 100;
            this.orbitSpeed = 0.3 + Math.random() * 0.4; // è½¨é“é€Ÿåº¦å€ç‡
            this.orbitPhase = Math.random() * Math.PI * 2;
            this.verticalOffset = Math.random() * 30; // å‚ç›´åç§»
            this.bobSpeed = 0.02 + Math.random() * 0.02; // ä¸Šä¸‹æµ®åŠ¨é€Ÿåº¦
            this.bobPhase = Math.random() * Math.PI * 2;
            this.bobAmount = 5 + Math.random() * 10;
            
            // ç¤¼ç‰©ç›’å¤§å°
            this.width = 22 + Math.random() * 28;
            this.height = 18 + Math.random() * 22;
            
            // é¢œè‰²
            const boxColors = ['#E74C3C', '#3498DB', '#2ECC71', '#9B59B6', '#F39C12', '#1ABC9C', '#E91E63', '#00BCD4'];
            const ribbonColors = ['#FFD700', '#FFFFFF', '#FF69B4', '#C0C0C0', '#FFF59D'];
            this.boxColor = boxColors[Math.floor(Math.random() * boxColors.length)];
            this.ribbonColor = ribbonColors[Math.floor(Math.random() * ribbonColors.length)];
            
            // è‡ªè½¬
            this.selfRotation = 0;
            this.selfRotationSpeed = (Math.random() - 0.5) * 0.02;
        }
        
        render(rotationOffset, ctx) {
            // å¤æ‚è½¨é“ï¼šä¸»æ—‹è½¬ + è‡ªèº«è½¨é“åç§»
            let mainAngle = this.baseAngle + rotationOffset * this.orbitSpeed;
            let wobble = Math.sin(rotationOffset * 2 + this.orbitPhase) * 20;
            let effectiveRadius = this.orbitRadius + wobble;
            
            let xPos = Math.cos(mainAngle) * effectiveRadius;
            let zPos = Math.sin(mainAngle) * effectiveRadius;
            
            // ä¸Šä¸‹æµ®åŠ¨
            this.bobPhase += this.bobSpeed;
            let yPos = TREE_HEIGHT / 2 + 30 + this.verticalOffset + Math.sin(this.bobPhase) * this.bobAmount;
            
            let zDepth = FOCAL_LENGTH + zPos;
            if (zDepth < 10) zDepth = 10;
            let scale = FOCAL_LENGTH / zDepth;
            
            let screenX = width / 2 + xPos * scale;
            let screenY = height / 2 + yPos * scale + 50;
            let boxW = this.width * scale;
            let boxH = this.height * scale;
            
            // è‡ªè½¬
            this.selfRotation += this.selfRotationSpeed;
            
            ctx.save();
            ctx.translate(screenX, screenY - boxH / 2);
            ctx.rotate(Math.sin(this.selfRotation) * 0.1);
            ctx.translate(-screenX, -(screenY - boxH / 2));
            ctx.globalAlpha = Math.min(1, scale * 0.95);
            
            // ç¤¼ç‰©ç›’ä¸»ä½“
            ctx.fillStyle = this.boxColor;
            ctx.fillRect(screenX - boxW / 2, screenY - boxH, boxW, boxH);
            
            // ç¤¼ç‰©ç›’é˜´å½±/ä¾§é¢
            ctx.fillStyle = this.darkenColor(this.boxColor, 40);
            ctx.fillRect(screenX - boxW / 2, screenY - boxH, boxW * 0.12, boxH);
            ctx.fillRect(screenX - boxW / 2, screenY - boxH * 0.15, boxW, boxH * 0.15);
            
            // æ¨ªå‘ä¸å¸¦
            ctx.fillStyle = this.ribbonColor;
            ctx.fillRect(screenX - boxW / 2, screenY - boxH / 2 - boxH * 0.12, boxW, boxH * 0.24);
            
            // çºµå‘ä¸å¸¦
            ctx.fillRect(screenX - boxW * 0.12, screenY - boxH, boxW * 0.24, boxH);
            
            // è´è¶ç»“
            ctx.beginPath();
            ctx.ellipse(screenX - boxW * 0.18, screenY - boxH - boxH * 0.08, boxW * 0.14, boxW * 0.1, -0.3, 0, Math.PI * 2);
            ctx.ellipse(screenX + boxW * 0.18, screenY - boxH - boxH * 0.08, boxW * 0.14, boxW * 0.1, 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // è´è¶ç»“ä¸­å¿ƒ
            ctx.beginPath();
            ctx.arc(screenX, screenY - boxH - boxH * 0.05, boxW * 0.08, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        darkenColor(color, amount) {
            const hex = color.replace('#', '');
            const r = Math.max(0, parseInt(hex.substr(0, 2), 16) - amount);
            const g = Math.max(0, parseInt(hex.substr(2, 2), 16) - amount);
            const b = Math.max(0, parseInt(hex.substr(4, 2), 16) - amount);
            return `rgb(${r},${g},${b})`;
        }
    }
    
    // åˆå§‹åŒ–æ•°ç»„
    let confetti = [];
    let leaves = [];
    let gifts = [];
    let ornaments = [];

    class Particle {
        constructor(id) {
            this.id = id;
            this.init();
        }

        init() {
            // è°ƒæ•´åˆ†å¸ƒï¼šä½¿ç”¨æ›´å°çš„æŒ‡æ•°è®©æ›´å¤šç²’å­åˆ†å¸ƒåœ¨åº•éƒ¨
            let progress = this.id / PARTICLE_COUNT;
            this.y = -TREE_HEIGHT / 2 + Math.pow(progress, 0.55) * TREE_HEIGHT; // æ›´å°çš„æŒ‡æ•°è®©åº•éƒ¨æ›´å¯†é›†
            let yPercent = (this.y + TREE_HEIGHT / 2) / TREE_HEIGHT;
            this.targetRadius = yPercent * BASE_RADIUS;
            // å¢åŠ éšæœºåŠå¾„åç§»ï¼Œè®©æ ‘æ›´æœ‰å±‚æ¬¡æ„Ÿ
            this.radius = this.targetRadius * (0.85 + Math.random() * 0.3);
            this.angle = this.id * SPIN_LAYER_DENSITY + Math.random() * 0.5;

            const rand = Math.random();
            if (rand > 0.985) {
                // é‡‘è‰²æ˜Ÿæ˜Ÿè£…é¥°
                this.color = `hsla(45, 100%, ${70 + Math.random() * 30}%, 1)`; 
                this.baseSize = 3.0;
                this.isOrnament = true;
                this.ornamentType = 'star';
            } else if (rand > 0.97) {
                // çº¢è‰²åœ†çƒè£…é¥°
                this.color = `hsla(${355 + Math.random() * 10}, 90%, 50%, 1)`;
                this.baseSize = 2.8;
                this.isOrnament = true;
                this.ornamentType = 'ball';
            } else if (rand > 0.96) {
                // è“è‰²è£…é¥°çƒ
                this.color = `hsla(${210 + Math.random() * 20}, 85%, 55%, 1)`;
                this.baseSize = 2.5;
                this.isOrnament = true;
                this.ornamentType = 'ball';
            } else if (rand > 0.95) {
                // é“¶è‰²/ç™½è‰²è£…é¥°
                this.color = `hsla(0, 0%, ${88 + Math.random() * 12}%, 1)`;
                this.baseSize = 2.2;
                this.isOrnament = true;
                this.ornamentType = 'light';
            } else if (rand > 0.94) {
                // ç´«è‰²è£…é¥°
                this.color = `hsla(${280 + Math.random() * 20}, 70%, 55%, 1)`;
                this.baseSize = 2.3;
                this.isOrnament = true;
                this.ornamentType = 'ball';
            } else if (rand > 0.93) {
                // æ©™è‰²å°ç¯
                this.color = `hsla(${30 + Math.random() * 15}, 100%, 55%, 1)`;
                this.baseSize = 1.8;
                this.isOrnament = true;
                this.ornamentType = 'light';
            } else if (rand > 0.92) {
                // ç²‰è‰²è£…é¥°
                this.color = `hsla(${330 + Math.random() * 20}, 80%, 70%, 1)`;
                this.baseSize = 2.0;
                this.isOrnament = true;
                this.ornamentType = 'ball';
            } else if (rand > 0.91) {
                // é’è‰²å°ç¯
                this.color = `hsla(${175 + Math.random() * 15}, 90%, 60%, 1)`;
                this.baseSize = 1.6;
                this.isOrnament = true;
                this.ornamentType = 'light';
            } else {
                // ç»¿è‰²æ ‘å¶ - å¤§éƒ¨åˆ†ç²’å­
                let hue = 115 + Math.random() * 55; 
                let sat = 60 + Math.random() * 30;
                let light = 18 + Math.random() * 32;
                this.color = `hsla(${hue}, ${sat}%, ${light}%, 0.95)`;
                this.baseSize = 1.4 + Math.random() * 0.8;
                this.isOrnament = false;
                this.ornamentType = 'leaf';
            }

            this.vx = (Math.random() - 0.5) * 25;
            this.vy = (Math.random() - 0.5) * 25;
            this.vz = (Math.random() - 0.5) * 25;
            
            this.dx = 0;
            this.dy = 0;
            this.dz = 0;
        }

        update() {
            if (explodeForce > 0.01) {
                this.dx += this.vx * explodeForce * 0.5;
                this.dy += this.vy * explodeForce * 0.5;
                this.dz += this.vz * explodeForce * 0.5;
            } else {
                this.dx *= 0.92;
                this.dy *= 0.92;
                this.dz *= 0.92;
            }
        }

        render(rotationOffset, ctx) {
            let effectiveAngle = this.angle + rotationOffset;
            let rawX = Math.cos(effectiveAngle) * this.radius;
            let rawZ = Math.sin(effectiveAngle) * this.radius;
            let rawY = this.y;

            let x = rawX + this.dx;
            let y = rawY + this.dy;
            let z = rawZ + this.dz;

            let zDepth = FOCAL_LENGTH + z; 
            if (zDepth < 10) zDepth = 10;
            let scale = FOCAL_LENGTH / zDepth;

            let screenX = width / 2 + x * scale;
            let screenY = height / 2 + y * scale + 50; 

            let size = this.baseSize * scale;
            let alpha = Math.min(1, scale * 0.8);

            ctx.fillStyle = this.color;
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
            ctx.fill();

            if (this.isOrnament && Math.random() > 0.92) {
                ctx.globalAlpha = alpha * 0.6;
                ctx.beginPath();
                ctx.arc(screenX, screenY, size * 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // é—ªçƒæ•ˆæœ
            if (this.ornamentType === 'light' && Math.random() > 0.97) {
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.arc(screenX, screenY, size * 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    function initParticles() {
        particles = [];
        confetti = [];
        leaves = [];
        gifts = [];
        ornaments = [];
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            particles.push(new Particle(i));
        }
        for (let i = 0; i < CONFETTI_COUNT; i++) {
            confetti.push(new Confetti());
        }
        for (let i = 0; i < LEAF_COUNT; i++) {
            leaves.push(new Leaf());
        }
        for (let i = 0; i < GIFT_COUNT; i++) {
            gifts.push(new GiftBox(i));
        }
        for (let i = 0; i < ORNAMENT_COUNT; i++) {
            ornaments.push(new Ornament());
        }
    }
    initParticles();

    // é¼ æ ‡è¾“å…¥é€»è¾‘
    function handleMouseMove(normalizedX) {
        if (isHandControlling) return; // å¦‚æœæ­£åœ¨ä½¿ç”¨æ‰‹åŠ¿ï¼Œå¿½ç•¥é¼ æ ‡
        
        let x = (normalizedX - 0.5) * 2; 
        targetRotationSpeed = x * 0.15;
        autoRotate = false;
        clearTimeout(idleTimer);
        idleTimer = setTimeout(() => { autoRotate = true; }, 1000);
    }

    function triggerExplode() {
        explodeForce = 1.0;
        // åªæœ‰ç¬¬ä¸€æ¬¡çˆ†å¼€æ—¶è®¾ç½®æ˜Ÿæ˜Ÿè·³åŠ¨
        if (!hasExplodedOnce) {
            hasExplodedOnce = true;
            starJumpOffset = 50; // ç¬¬ä¸€æ¬¡çˆ†å¼€æ—¶è·³åŠ¨
        }
    }

    let idleTimer;
    document.addEventListener('mousemove', (e) => { handleMouseMove(e.clientX / width); });
    document.addEventListener('mousedown', triggerExplode);
    document.addEventListener('touchmove', (e) => { if(e.touches.length > 0) handleMouseMove(e.touches[0].clientX / width); }, { passive: true });
    document.addEventListener('touchstart', (e) => { triggerExplode(); if(e.touches.length > 0) handleMouseMove(e.touches[0].clientX / width); }, { passive: true });


    // ç»˜åˆ¶æ˜Ÿæ˜Ÿ
    function drawStar(ctx, rot) {
        let x = width / 2;
        let topY = -TREE_HEIGHT / 2;
        let zDepth = FOCAL_LENGTH; 
        let scale = FOCAL_LENGTH / zDepth;
        let y = height / 2 + topY * scale + 50;
        
        // æ˜Ÿæ˜Ÿè·³åŠ¨é€æ¸æ¢å¤ï¼ˆåªåœ¨ç¬¬ä¸€æ¬¡çˆ†å¼€æ—¶æœ‰æ•ˆï¼‰
        if (starJumpOffset > 0) {
            y -= starJumpOffset;
            starJumpOffset *= 0.92; // é€æ¸æ¢å¤
            if (starJumpOffset < 0.5) starJumpOffset = 0;
        } 

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(-rot * 2);
        
        ctx.shadowBlur = 30;
        ctx.shadowColor = "rgba(255, 230, 150, 0.8)";
        ctx.fillStyle = "#fffd70";
        
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
            ctx.lineTo(Math.cos((18 + i * 72) / 180 * Math.PI) * 18 * scale,
                       -Math.sin((18 + i * 72) / 180 * Math.PI) * 18 * scale);
            ctx.lineTo(Math.cos((54 + i * 72) / 180 * Math.PI) * 8 * scale,
                       -Math.sin((54 + i * 72) / 180 * Math.PI) * 8 * scale);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }

    let rotation = 0;
    function animate() {
        ctx.clearRect(0, 0, width, height);

        if (autoRotate && !isHandControlling) {
            targetRotationSpeed = 0.004;
        }
        
        currentRotationSpeed += (targetRotationSpeed - currentRotationSpeed) * 0.05;
        rotation += currentRotationSpeed;

        if (explodeForce > 0) {
            explodeForce *= 0.94;
            if (explodeForce < 0.001) explodeForce = 0;
        }

        // ç»˜åˆ¶ç¤¼ç‰©ç›’ï¼ˆåœ¨æœ€åº•å±‚ï¼Œå¤æ‚æ—‹è½¬è·¯å¾„ï¼‰
        gifts.forEach(g => g.render(rotation, ctx));
        
        // æ›´æ–°å¹¶ç»˜åˆ¶æ ‘å¶ï¼ˆè´´ç€è¾¹ç¼˜ï¼‰
        leaves.forEach(leaf => {
            leaf.update();
            leaf.render(rotation, ctx);
        });

        // æ›´æ–°å¹¶ç»˜åˆ¶ç²’å­
        particles.forEach(p => {
            p.update();
            p.render(rotation, ctx);
        });
        
        // æ›´æ–°å¹¶ç»˜åˆ¶å½©å¸¦ç¢ç‰‡
        confetti.forEach(c => {
            c.update();
            c.render(rotation, ctx);
        });
        
        // æ›´æ–°å¹¶ç»˜åˆ¶é“ƒé“›å’Œæ˜Ÿæ˜Ÿè£…é¥°
        ornaments.forEach(o => {
            o.update();
            o.render(rotation, ctx);
        });
        
        // æœ€åç»˜åˆ¶é¡¶éƒ¨æ˜Ÿæ˜Ÿ
        ctx.globalAlpha = 1;
        drawStar(ctx, rotation);
        
        requestAnimationFrame(animate);
    }
    animate();


    /**
     * PART 2: MediaPipe Hands Integration
     */
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const cameraPreview = document.getElementById('camera-preview');
    const loadingText = document.getElementById('loading-text');

    function onResults(results) {
        // éšè— loading
        loadingText.style.display = 'none';

        // è°ƒè¯•ï¼šç¡®è®¤å›è°ƒè¢«è°ƒç”¨
        console.log('onResults called, hands detected:', results.multiHandLandmarks ? results.multiHandLandmarks.length : 0);

        // æ¸…é™¤ç”»å¸ƒ
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        // ç»˜åˆ¶é¢„è§ˆç”»é¢ (ä¸éœ€è¦æ‰‹åŠ¨é•œåƒï¼Œå› ä¸ºCSSå·²ç»åšäº†é•œåƒ)
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            isHandControlling = true;
            
            // å–ç¬¬ä¸€åªæ£€æµ‹åˆ°çš„æ‰‹
            const landmarks = results.multiHandLandmarks[0];
            
            // ç»˜åˆ¶éª¨éª¼ (ä½¿ç”¨ç”»å¸ƒå°ºå¯¸æ¥æ­£ç¡®ç¼©æ”¾)
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

            // 1. æ—‹è½¬æ§åˆ¶ï¼šåŸºäºé£ŸæŒ‡æŒ‡å°– (Index Finger Tip - ç´¢å¼• 8) çš„ X åæ ‡
            // åæ ‡èŒƒå›´ 0.0 (å·¦) - 1.0 (å³)
            const indexTip = landmarks[8];
            const x = indexTip.x; 
            
            // æ˜ å°„ï¼šå› ä¸ºCSSåšäº†é•œåƒï¼Œç”¨æˆ·çœ‹åˆ°çš„ç”»é¢æ˜¯é•œåƒçš„
            // åŸå§‹x: æ‰‹åœ¨æ‘„åƒå¤´å·¦è¾¹ -> xå°; æ‰‹åœ¨æ‘„åƒå¤´å³è¾¹ -> xå¤§
            // é•œåƒåç”¨æˆ·çœ‹åˆ°çš„: æ‰‹åœ¨å±å¹•å³è¾¹ -> åŸå§‹xå°
            // æ‰€ä»¥éœ€è¦åè½¬: (0.5 - x) è®©æ‰‹å¾€å³ç§»æ—¶æ ‘å¾€å³è½¬
            const rotationInput = (0.5 - x) * 2; // -1 to 1
            targetRotationSpeed = rotationInput * 0.15; 


            // 2. çˆ†ç‚¸æ§åˆ¶ï¼šåŸºäºå¤§æ‹‡æŒ‡ (4) å’Œ é£ŸæŒ‡ (8) çš„è·ç¦» (Pinch)
            const thumbTip = landmarks[4];
            const distance = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);

            // å½“è·ç¦»å°äºé˜ˆå€¼æ—¶ (æåˆ)
            if (distance < 0.05) {
                explodeForce = 1.0;
                // è§†è§‰åé¦ˆï¼šåœ¨é¢„è§ˆé‡Œç”»ä¸ªåœˆ
                canvasCtx.beginPath();
                canvasCtx.arc(indexTip.x * canvasElement.width, indexTip.y * canvasElement.height, 20, 0, 2 * Math.PI);
                canvasCtx.fillStyle = "rgba(255, 255, 0, 0.5)";
                canvasCtx.fill();
            }

        } else {
            // æ²¡æœ‰æ£€æµ‹åˆ°æ‰‹ï¼Œæ¢å¤è‡ªåŠ¨æ—‹è½¬
            isHandControlling = false;
        }
    }

    // åœæ­¢æ‘„åƒå¤´
    function stopCamera() {
        const btn = document.getElementById('btn-camera');
        
        if (cameraInstance) {
            cameraInstance.stop();
            cameraInstance = null;
        }
        
        if (handsInstance) {
            handsInstance.close();
            handsInstance = null;
        }
        
        isCameraRunning = false;
        isHandControlling = false;
        cameraPreview.style.display = 'none';
        btn.innerText = "å¼€å¯æ‘„åƒå¤´æ§åˆ¶";
        btn.style.background = "rgba(255, 255, 255, 0.1)";
        btn.style.borderColor = "rgba(255, 255, 255, 0.3)";
        btn.disabled = false;
        
        console.log('æ‘„åƒå¤´å·²å…³é—­');
    }

    // å¯åŠ¨æ‘„åƒå¤´é€»è¾‘
    function startCamera() {
        const btn = document.getElementById('btn-camera');
        
        // å¦‚æœæ‘„åƒå¤´æ­£åœ¨è¿è¡Œï¼Œåˆ™å…³é—­
        if (isCameraRunning) {
            stopCamera();
            return;
        }
        
        btn.innerText = "æ­£åœ¨å¯åŠ¨...";
        btn.disabled = true;
        
        cameraPreview.style.display = 'block';
        loadingText.style.display = 'block';

        console.log('æ­£åœ¨åˆå§‹åŒ– MediaPipe Hands...');
        
        // æ£€æŸ¥ MediaPipe åº“æ˜¯å¦åŠ è½½æˆåŠŸ
        if (typeof Hands === 'undefined') {
            console.error('MediaPipe Hands åº“æœªåŠ è½½ï¼');
            alert('MediaPipe Hands åº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥å¹¶åˆ·æ–°é¡µé¢ã€‚');
            btn.innerText = "åº“åŠ è½½å¤±è´¥";
            btn.disabled = false;
            loadingText.style.display = 'none';
            return;
        }
        
        if (typeof Camera === 'undefined') {
            console.error('MediaPipe Camera åº“æœªåŠ è½½ï¼');
            alert('MediaPipe Camera åº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥å¹¶åˆ·æ–°é¡µé¢ã€‚');
            btn.innerText = "åº“åŠ è½½å¤±è´¥";
            btn.disabled = false;
            loadingText.style.display = 'none';
            return;
        }

        console.log('åº“åŠ è½½æˆåŠŸï¼Œåˆ›å»º Hands å®ä¾‹...');

        try {
            handsInstance = new Hands({locateFile: (file) => {
                console.log('åŠ è½½ MediaPipe æ–‡ä»¶:', file);
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
        } catch (e) {
            console.error('åˆ›å»º Hands å®ä¾‹å¤±è´¥:', e);
            alert('åˆ›å»º Hands å®ä¾‹å¤±è´¥: ' + e.message);
            btn.innerText = "åˆå§‹åŒ–å¤±è´¥";
            btn.disabled = false;
            loadingText.style.display = 'none';
            return;
        }

        console.log('Hands å®ä¾‹åˆ›å»ºæˆåŠŸï¼Œè®¾ç½®é€‰é¡¹...');

        handsInstance.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        handsInstance.onResults(onResults);

        console.log('å¼€å§‹åˆå§‹åŒ–æ¨¡å‹...');

        // åˆå§‹åŒ– hands æ¨¡å‹
        handsInstance.initialize().then(() => {
            console.log('MediaPipe Hands åˆå§‹åŒ–å®Œæˆï¼Œå¯åŠ¨æ‘„åƒå¤´...');
            
            cameraInstance = new Camera(videoElement, {
                onFrame: async () => {
                    if (handsInstance && isCameraRunning) {
                        try {
                            await handsInstance.send({image: videoElement});
                        } catch (e) {
                            console.error('å‘é€å¸§åˆ° MediaPipe å¤±è´¥:', e);
                        }
                    }
                },
                width: 320,
                height: 240
            });

            console.log('Camera å®ä¾‹åˆ›å»ºæˆåŠŸï¼Œè°ƒç”¨ start()...');

            cameraInstance.start()
                .then(() => {
                    console.log('æ‘„åƒå¤´å¯åŠ¨æˆåŠŸ');
                    isCameraRunning = true;
                    btn.innerText = "å…³é—­æ‘„åƒå¤´æ§åˆ¶";
                    btn.style.background = "rgba(0, 255, 0, 0.2)";
                    btn.style.borderColor = "rgba(0, 255, 0, 0.5)";
                    btn.disabled = false;
                })
                .catch(err => {
                    console.error('æ‘„åƒå¤´å¯åŠ¨å¤±è´¥:', err);
                    btn.innerText = "å¯åŠ¨å¤±è´¥";
                    btn.disabled = false;
                    loadingText.style.display = 'none';
                    alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ã€‚è¯·ç¡®ä¿ï¼š\n1. å·²æˆæƒæ‘„åƒå¤´æƒé™\n2. åœ¨ HTTPS æˆ– localhost ç¯å¢ƒä¸‹è¿è¡Œ\n3. æ²¡æœ‰å…¶ä»–ç¨‹åºå ç”¨æ‘„åƒå¤´\n\né”™è¯¯: " + err.message);
                });
        }).catch(err => {
            console.error('MediaPipe Hands åˆå§‹åŒ–å¤±è´¥:', err);
            btn.innerText = "åˆå§‹åŒ–å¤±è´¥";
            btn.disabled = false;
            loadingText.style.display = 'none';
            alert("MediaPipe åˆå§‹åŒ–å¤±è´¥: " + err.message);
        });
    }

    // ç»‘å®šæŒ‰é’®ç‚¹å‡»äº‹ä»¶
    document.getElementById('btn-camera').addEventListener('click', function() {
        console.log('æŒ‰é’®è¢«ç‚¹å‡»');
        startCamera();
    });

</script>
</body>
</html>